<!--
This file was generated by Spark. Do not edit it by hand.
-->
# Reactor.File

An extension which provides steps for working with the local filesystem within
Reactor.



### reactor.chgrp
```elixir
chgrp name
```


Change the group of a file or directory.

Uses `File.chgrp/2`.


### Nested DSLs
 * [wait_for](#reactor-chgrp-wait_for)
 * [guard](#reactor-chgrp-guard)
 * [where](#reactor-chgrp-where)




### Arguments

| Name | Type | Default | Docs |
|------|------|---------|------|
| [`name`](#reactor-chgrp-name){: #reactor-chgrp-name .spark-required} | `atom` |  | A unique name for the step. Used when choosing the return value of the Reactor and for arguments into other steps |
### Options

| Name | Type | Default | Docs |
|------|------|---------|------|
| [`path`](#reactor-chgrp-path){: #reactor-chgrp-path .spark-required} | `Reactor.Template.Element \| Reactor.Template.Input \| Reactor.Template.Result \| Reactor.Template.Value` |  | The path to the file or directory |
| [`gid`](#reactor-chgrp-gid){: #reactor-chgrp-gid .spark-required} | `Reactor.Template.Element \| Reactor.Template.Input \| Reactor.Template.Result \| Reactor.Template.Value` |  | The GID to set the file group to |
| [`description`](#reactor-chgrp-description){: #reactor-chgrp-description } | `String.t` |  | An optional description for the step |
| [`revert_on_undo?`](#reactor-chgrp-revert_on_undo?){: #reactor-chgrp-revert_on_undo? } | `boolean` | `false` | Change the GID back to the original value on undo? |


### reactor.chgrp.wait_for
```elixir
wait_for names
```


Wait for the named step to complete before allowing this one to start.

Desugars to `argument :_, result(step_to_wait_for)`




### Examples
```
wait_for :create_user
```



### Arguments

| Name | Type | Default | Docs |
|------|------|---------|------|
| [`names`](#reactor-chgrp-wait_for-names){: #reactor-chgrp-wait_for-names .spark-required} | `atom \| list(atom)` |  | The name of the step to wait for. |
### Options

| Name | Type | Default | Docs |
|------|------|---------|------|
| [`description`](#reactor-chgrp-wait_for-description){: #reactor-chgrp-wait_for-description } | `String.t` |  | An optional description. |





### Introspection

Target: `Reactor.Dsl.WaitFor`

### reactor.chgrp.guard
```elixir
guard fun
```


Provides a flexible method for conditionally executing a step, or replacing it's result.

Expects a two arity function which takes the step's arguments and context and returns one of the following:

- `:cont` - the guard has passed.
- `{:halt, result}` - the guard has failed - instead of executing the step use the provided result.




### Examples
```
step :read_file_via_cache do
  argument :path, input(:path)
  run &File.read(&1.path)
  guard fn %{path: path}, %{cache: cache} ->
    case Cache.get(cache, path) do
      {:ok, content} -> {:halt, {:ok, content}}
      _ -> :cont
    end
  end
end

```



### Arguments

| Name | Type | Default | Docs |
|------|------|---------|------|
| [`fun`](#reactor-chgrp-guard-fun){: #reactor-chgrp-guard-fun .spark-required} | `(any, any -> any) \| mfa` |  | The guard function. |
### Options

| Name | Type | Default | Docs |
|------|------|---------|------|
| [`description`](#reactor-chgrp-guard-description){: #reactor-chgrp-guard-description } | `String.t` |  | An optional description of the guard. |





### Introspection

Target: `Reactor.Dsl.Guard`

### reactor.chgrp.where
```elixir
where predicate
```


Only execute the surrounding step if the predicate function returns true.

This is a simple version of `guard` which provides more flexibility at the cost of complexity.




### Examples
```
step :read_file do
  argument :path, input(:path)
  run &File.read(&1.path)
  where &File.exists?(&1.path)
end

```



### Arguments

| Name | Type | Default | Docs |
|------|------|---------|------|
| [`predicate`](#reactor-chgrp-where-predicate){: #reactor-chgrp-where-predicate .spark-required} | `(any -> any) \| mfa \| (any, any -> any) \| mfa` |  | Provide a function which takes the step arguments and optionally the context and returns a boolean value. |
### Options

| Name | Type | Default | Docs |
|------|------|---------|------|
| [`description`](#reactor-chgrp-where-description){: #reactor-chgrp-where-description } | `String.t` |  | An optional description of the guard. |





### Introspection

Target: `Reactor.Dsl.Where`




### Introspection

Target: `Reactor.File.Dsl.Chgrp`



### reactor.chown
```elixir
chown name
```


Change the owner of a file or directory.

Uses `File.chown/2`.


### Nested DSLs
 * [wait_for](#reactor-chown-wait_for)
 * [guard](#reactor-chown-guard)
 * [where](#reactor-chown-where)




### Arguments

| Name | Type | Default | Docs |
|------|------|---------|------|
| [`name`](#reactor-chown-name){: #reactor-chown-name .spark-required} | `atom` |  | A unique name for the step. Used when choosing the return value of the Reactor and for arguments into other steps |
### Options

| Name | Type | Default | Docs |
|------|------|---------|------|
| [`path`](#reactor-chown-path){: #reactor-chown-path .spark-required} | `Reactor.Template.Element \| Reactor.Template.Input \| Reactor.Template.Result \| Reactor.Template.Value` |  | The path to the file or directory |
| [`uid`](#reactor-chown-uid){: #reactor-chown-uid .spark-required} | `Reactor.Template.Element \| Reactor.Template.Input \| Reactor.Template.Result \| Reactor.Template.Value` |  | The UID to set the file owner to |
| [`description`](#reactor-chown-description){: #reactor-chown-description } | `String.t` |  | An optional description for the step |
| [`revert_on_undo?`](#reactor-chown-revert_on_undo?){: #reactor-chown-revert_on_undo? } | `boolean` | `false` | Change the UID back to the original value on undo? |


### reactor.chown.wait_for
```elixir
wait_for names
```


Wait for the named step to complete before allowing this one to start.

Desugars to `argument :_, result(step_to_wait_for)`




### Examples
```
wait_for :create_user
```



### Arguments

| Name | Type | Default | Docs |
|------|------|---------|------|
| [`names`](#reactor-chown-wait_for-names){: #reactor-chown-wait_for-names .spark-required} | `atom \| list(atom)` |  | The name of the step to wait for. |
### Options

| Name | Type | Default | Docs |
|------|------|---------|------|
| [`description`](#reactor-chown-wait_for-description){: #reactor-chown-wait_for-description } | `String.t` |  | An optional description. |





### Introspection

Target: `Reactor.Dsl.WaitFor`

### reactor.chown.guard
```elixir
guard fun
```


Provides a flexible method for conditionally executing a step, or replacing it's result.

Expects a two arity function which takes the step's arguments and context and returns one of the following:

- `:cont` - the guard has passed.
- `{:halt, result}` - the guard has failed - instead of executing the step use the provided result.




### Examples
```
step :read_file_via_cache do
  argument :path, input(:path)
  run &File.read(&1.path)
  guard fn %{path: path}, %{cache: cache} ->
    case Cache.get(cache, path) do
      {:ok, content} -> {:halt, {:ok, content}}
      _ -> :cont
    end
  end
end

```



### Arguments

| Name | Type | Default | Docs |
|------|------|---------|------|
| [`fun`](#reactor-chown-guard-fun){: #reactor-chown-guard-fun .spark-required} | `(any, any -> any) \| mfa` |  | The guard function. |
### Options

| Name | Type | Default | Docs |
|------|------|---------|------|
| [`description`](#reactor-chown-guard-description){: #reactor-chown-guard-description } | `String.t` |  | An optional description of the guard. |





### Introspection

Target: `Reactor.Dsl.Guard`

### reactor.chown.where
```elixir
where predicate
```


Only execute the surrounding step if the predicate function returns true.

This is a simple version of `guard` which provides more flexibility at the cost of complexity.




### Examples
```
step :read_file do
  argument :path, input(:path)
  run &File.read(&1.path)
  where &File.exists?(&1.path)
end

```



### Arguments

| Name | Type | Default | Docs |
|------|------|---------|------|
| [`predicate`](#reactor-chown-where-predicate){: #reactor-chown-where-predicate .spark-required} | `(any -> any) \| mfa \| (any, any -> any) \| mfa` |  | Provide a function which takes the step arguments and optionally the context and returns a boolean value. |
### Options

| Name | Type | Default | Docs |
|------|------|---------|------|
| [`description`](#reactor-chown-where-description){: #reactor-chown-where-description } | `String.t` |  | An optional description of the guard. |





### Introspection

Target: `Reactor.Dsl.Where`




### Introspection

Target: `Reactor.File.Dsl.Chown`



### reactor.chmod
```elixir
chmod name
```


Change the permissions of a file or directory.

Uses `File.chmod/2`.


### Nested DSLs
 * [wait_for](#reactor-chmod-wait_for)
 * [guard](#reactor-chmod-guard)
 * [where](#reactor-chmod-where)




### Arguments

| Name | Type | Default | Docs |
|------|------|---------|------|
| [`name`](#reactor-chmod-name){: #reactor-chmod-name .spark-required} | `atom` |  | A unique name for the step. Used when choosing the return value of the Reactor and for arguments into other steps |
### Options

| Name | Type | Default | Docs |
|------|------|---------|------|
| [`path`](#reactor-chmod-path){: #reactor-chmod-path .spark-required} | `Reactor.Template.Element \| Reactor.Template.Input \| Reactor.Template.Result \| Reactor.Template.Value` |  | The path to the file or directory |
| [`mode`](#reactor-chmod-mode){: #reactor-chmod-mode .spark-required} | `Reactor.Template.Element \| Reactor.Template.Input \| Reactor.Template.Result \| Reactor.Template.Value` |  | The mode to set the file permissions to |
| [`description`](#reactor-chmod-description){: #reactor-chmod-description } | `String.t` |  | An optional description for the step |
| [`revert_on_undo?`](#reactor-chmod-revert_on_undo?){: #reactor-chmod-revert_on_undo? } | `boolean` | `false` | Change the permissions back to the original value on undo? |


### reactor.chmod.wait_for
```elixir
wait_for names
```


Wait for the named step to complete before allowing this one to start.

Desugars to `argument :_, result(step_to_wait_for)`




### Examples
```
wait_for :create_user
```



### Arguments

| Name | Type | Default | Docs |
|------|------|---------|------|
| [`names`](#reactor-chmod-wait_for-names){: #reactor-chmod-wait_for-names .spark-required} | `atom \| list(atom)` |  | The name of the step to wait for. |
### Options

| Name | Type | Default | Docs |
|------|------|---------|------|
| [`description`](#reactor-chmod-wait_for-description){: #reactor-chmod-wait_for-description } | `String.t` |  | An optional description. |





### Introspection

Target: `Reactor.Dsl.WaitFor`

### reactor.chmod.guard
```elixir
guard fun
```


Provides a flexible method for conditionally executing a step, or replacing it's result.

Expects a two arity function which takes the step's arguments and context and returns one of the following:

- `:cont` - the guard has passed.
- `{:halt, result}` - the guard has failed - instead of executing the step use the provided result.




### Examples
```
step :read_file_via_cache do
  argument :path, input(:path)
  run &File.read(&1.path)
  guard fn %{path: path}, %{cache: cache} ->
    case Cache.get(cache, path) do
      {:ok, content} -> {:halt, {:ok, content}}
      _ -> :cont
    end
  end
end

```



### Arguments

| Name | Type | Default | Docs |
|------|------|---------|------|
| [`fun`](#reactor-chmod-guard-fun){: #reactor-chmod-guard-fun .spark-required} | `(any, any -> any) \| mfa` |  | The guard function. |
### Options

| Name | Type | Default | Docs |
|------|------|---------|------|
| [`description`](#reactor-chmod-guard-description){: #reactor-chmod-guard-description } | `String.t` |  | An optional description of the guard. |





### Introspection

Target: `Reactor.Dsl.Guard`

### reactor.chmod.where
```elixir
where predicate
```


Only execute the surrounding step if the predicate function returns true.

This is a simple version of `guard` which provides more flexibility at the cost of complexity.




### Examples
```
step :read_file do
  argument :path, input(:path)
  run &File.read(&1.path)
  where &File.exists?(&1.path)
end

```



### Arguments

| Name | Type | Default | Docs |
|------|------|---------|------|
| [`predicate`](#reactor-chmod-where-predicate){: #reactor-chmod-where-predicate .spark-required} | `(any -> any) \| mfa \| (any, any -> any) \| mfa` |  | Provide a function which takes the step arguments and optionally the context and returns a boolean value. |
### Options

| Name | Type | Default | Docs |
|------|------|---------|------|
| [`description`](#reactor-chmod-where-description){: #reactor-chmod-where-description } | `String.t` |  | An optional description of the guard. |





### Introspection

Target: `Reactor.Dsl.Where`




### Introspection

Target: `Reactor.File.Dsl.Chmod`



### reactor.cp
```elixir
cp name
```


Copy the source file to the destination.

Uses `File.cp/2`.


### Nested DSLs
 * [wait_for](#reactor-cp-wait_for)
 * [guard](#reactor-cp-guard)
 * [where](#reactor-cp-where)




### Arguments

| Name | Type | Default | Docs |
|------|------|---------|------|
| [`name`](#reactor-cp-name){: #reactor-cp-name .spark-required} | `atom` |  | A unique name for the step. Used when choosing the return value of the Reactor and for arguments into other steps |
### Options

| Name | Type | Default | Docs |
|------|------|---------|------|
| [`source`](#reactor-cp-source){: #reactor-cp-source .spark-required} | `Reactor.Template.Element \| Reactor.Template.Input \| Reactor.Template.Result \| Reactor.Template.Value` |  | The path to the source file |
| [`target`](#reactor-cp-target){: #reactor-cp-target .spark-required} | `Reactor.Template.Element \| Reactor.Template.Input \| Reactor.Template.Result \| Reactor.Template.Value` |  | The path to the target file |
| [`description`](#reactor-cp-description){: #reactor-cp-description } | `String.t` |  | An optional description for the step |
| [`overwrite?`](#reactor-cp-overwrite?){: #reactor-cp-overwrite? } | `boolean` | `true` | Whether or not to overwrite the target if it already exists |
| [`revert_on_undo?`](#reactor-cp-revert_on_undo?){: #reactor-cp-revert_on_undo? } | `boolean` | `false` | Revert back to the initial state on undo (either by removing the target or by setting it back to it's original content) |


### reactor.cp.wait_for
```elixir
wait_for names
```


Wait for the named step to complete before allowing this one to start.

Desugars to `argument :_, result(step_to_wait_for)`




### Examples
```
wait_for :create_user
```



### Arguments

| Name | Type | Default | Docs |
|------|------|---------|------|
| [`names`](#reactor-cp-wait_for-names){: #reactor-cp-wait_for-names .spark-required} | `atom \| list(atom)` |  | The name of the step to wait for. |
### Options

| Name | Type | Default | Docs |
|------|------|---------|------|
| [`description`](#reactor-cp-wait_for-description){: #reactor-cp-wait_for-description } | `String.t` |  | An optional description. |





### Introspection

Target: `Reactor.Dsl.WaitFor`

### reactor.cp.guard
```elixir
guard fun
```


Provides a flexible method for conditionally executing a step, or replacing it's result.

Expects a two arity function which takes the step's arguments and context and returns one of the following:

- `:cont` - the guard has passed.
- `{:halt, result}` - the guard has failed - instead of executing the step use the provided result.




### Examples
```
step :read_file_via_cache do
  argument :path, input(:path)
  run &File.read(&1.path)
  guard fn %{path: path}, %{cache: cache} ->
    case Cache.get(cache, path) do
      {:ok, content} -> {:halt, {:ok, content}}
      _ -> :cont
    end
  end
end

```



### Arguments

| Name | Type | Default | Docs |
|------|------|---------|------|
| [`fun`](#reactor-cp-guard-fun){: #reactor-cp-guard-fun .spark-required} | `(any, any -> any) \| mfa` |  | The guard function. |
### Options

| Name | Type | Default | Docs |
|------|------|---------|------|
| [`description`](#reactor-cp-guard-description){: #reactor-cp-guard-description } | `String.t` |  | An optional description of the guard. |





### Introspection

Target: `Reactor.Dsl.Guard`

### reactor.cp.where
```elixir
where predicate
```


Only execute the surrounding step if the predicate function returns true.

This is a simple version of `guard` which provides more flexibility at the cost of complexity.




### Examples
```
step :read_file do
  argument :path, input(:path)
  run &File.read(&1.path)
  where &File.exists?(&1.path)
end

```



### Arguments

| Name | Type | Default | Docs |
|------|------|---------|------|
| [`predicate`](#reactor-cp-where-predicate){: #reactor-cp-where-predicate .spark-required} | `(any -> any) \| mfa \| (any, any -> any) \| mfa` |  | Provide a function which takes the step arguments and optionally the context and returns a boolean value. |
### Options

| Name | Type | Default | Docs |
|------|------|---------|------|
| [`description`](#reactor-cp-where-description){: #reactor-cp-where-description } | `String.t` |  | An optional description of the guard. |





### Introspection

Target: `Reactor.Dsl.Where`




### Introspection

Target: `Reactor.File.Dsl.Cp`



### reactor.cp_r
```elixir
cp_r name
```


Copy the source file or directories to the destination.

Uses `File.cp_r/2`.


### Nested DSLs
 * [wait_for](#reactor-cp_r-wait_for)
 * [guard](#reactor-cp_r-guard)
 * [where](#reactor-cp_r-where)




### Arguments

| Name | Type | Default | Docs |
|------|------|---------|------|
| [`name`](#reactor-cp_r-name){: #reactor-cp_r-name .spark-required} | `atom` |  | A unique name for the step. Used when choosing the return value of the Reactor and for arguments into other steps |
### Options

| Name | Type | Default | Docs |
|------|------|---------|------|
| [`source`](#reactor-cp_r-source){: #reactor-cp_r-source .spark-required} | `Reactor.Template.Element \| Reactor.Template.Input \| Reactor.Template.Result \| Reactor.Template.Value` |  | The path to the source file |
| [`target`](#reactor-cp_r-target){: #reactor-cp_r-target .spark-required} | `Reactor.Template.Element \| Reactor.Template.Input \| Reactor.Template.Result \| Reactor.Template.Value` |  | The path to the target file |
| [`description`](#reactor-cp_r-description){: #reactor-cp_r-description } | `String.t` |  | An optional description for the step |
| [`overwrite?`](#reactor-cp_r-overwrite?){: #reactor-cp_r-overwrite? } | `boolean` | `true` | Whether or not to overwrite the target if it already exists |
| [`revert_on_undo?`](#reactor-cp_r-revert_on_undo?){: #reactor-cp_r-revert_on_undo? } | `boolean` | `false` | Revert back to the initial state on undo (either by removing the target or by setting it back to it's original content) |


### reactor.cp_r.wait_for
```elixir
wait_for names
```


Wait for the named step to complete before allowing this one to start.

Desugars to `argument :_, result(step_to_wait_for)`




### Examples
```
wait_for :create_user
```



### Arguments

| Name | Type | Default | Docs |
|------|------|---------|------|
| [`names`](#reactor-cp_r-wait_for-names){: #reactor-cp_r-wait_for-names .spark-required} | `atom \| list(atom)` |  | The name of the step to wait for. |
### Options

| Name | Type | Default | Docs |
|------|------|---------|------|
| [`description`](#reactor-cp_r-wait_for-description){: #reactor-cp_r-wait_for-description } | `String.t` |  | An optional description. |





### Introspection

Target: `Reactor.Dsl.WaitFor`

### reactor.cp_r.guard
```elixir
guard fun
```


Provides a flexible method for conditionally executing a step, or replacing it's result.

Expects a two arity function which takes the step's arguments and context and returns one of the following:

- `:cont` - the guard has passed.
- `{:halt, result}` - the guard has failed - instead of executing the step use the provided result.




### Examples
```
step :read_file_via_cache do
  argument :path, input(:path)
  run &File.read(&1.path)
  guard fn %{path: path}, %{cache: cache} ->
    case Cache.get(cache, path) do
      {:ok, content} -> {:halt, {:ok, content}}
      _ -> :cont
    end
  end
end

```



### Arguments

| Name | Type | Default | Docs |
|------|------|---------|------|
| [`fun`](#reactor-cp_r-guard-fun){: #reactor-cp_r-guard-fun .spark-required} | `(any, any -> any) \| mfa` |  | The guard function. |
### Options

| Name | Type | Default | Docs |
|------|------|---------|------|
| [`description`](#reactor-cp_r-guard-description){: #reactor-cp_r-guard-description } | `String.t` |  | An optional description of the guard. |





### Introspection

Target: `Reactor.Dsl.Guard`

### reactor.cp_r.where
```elixir
where predicate
```


Only execute the surrounding step if the predicate function returns true.

This is a simple version of `guard` which provides more flexibility at the cost of complexity.




### Examples
```
step :read_file do
  argument :path, input(:path)
  run &File.read(&1.path)
  where &File.exists?(&1.path)
end

```



### Arguments

| Name | Type | Default | Docs |
|------|------|---------|------|
| [`predicate`](#reactor-cp_r-where-predicate){: #reactor-cp_r-where-predicate .spark-required} | `(any -> any) \| mfa \| (any, any -> any) \| mfa` |  | Provide a function which takes the step arguments and optionally the context and returns a boolean value. |
### Options

| Name | Type | Default | Docs |
|------|------|---------|------|
| [`description`](#reactor-cp_r-where-description){: #reactor-cp_r-where-description } | `String.t` |  | An optional description of the guard. |





### Introspection

Target: `Reactor.Dsl.Where`




### Introspection

Target: `Reactor.File.Dsl.CpR`



### reactor.glob
```elixir
glob name
```


Searches for files matching the provided pattern.

Uses `Path.wildcard/2` under the hood.


### Nested DSLs
 * [wait_for](#reactor-glob-wait_for)
 * [guard](#reactor-glob-guard)
 * [where](#reactor-glob-where)




### Arguments

| Name | Type | Default | Docs |
|------|------|---------|------|
| [`name`](#reactor-glob-name){: #reactor-glob-name .spark-required} | `atom` |  | A unique name for the step. Used when choosing the return value of the Reactor and for arguments into other steps |
### Options

| Name | Type | Default | Docs |
|------|------|---------|------|
| [`pattern`](#reactor-glob-pattern){: #reactor-glob-pattern .spark-required} | `Reactor.Template.Element \| Reactor.Template.Input \| Reactor.Template.Result \| Reactor.Template.Value` |  | A pattern used to select files. See `Path.wildcard/2` for more information. |
| [`description`](#reactor-glob-description){: #reactor-glob-description } | `String.t` |  | An optional description for the step |
| [`match_dot`](#reactor-glob-match_dot){: #reactor-glob-match_dot } | `boolean` | `false` | Whether or not files starting with a `.` will be matched by the pattern. See `Path.wildcard/2` for more information. |


### reactor.glob.wait_for
```elixir
wait_for names
```


Wait for the named step to complete before allowing this one to start.

Desugars to `argument :_, result(step_to_wait_for)`




### Examples
```
wait_for :create_user
```



### Arguments

| Name | Type | Default | Docs |
|------|------|---------|------|
| [`names`](#reactor-glob-wait_for-names){: #reactor-glob-wait_for-names .spark-required} | `atom \| list(atom)` |  | The name of the step to wait for. |
### Options

| Name | Type | Default | Docs |
|------|------|---------|------|
| [`description`](#reactor-glob-wait_for-description){: #reactor-glob-wait_for-description } | `String.t` |  | An optional description. |





### Introspection

Target: `Reactor.Dsl.WaitFor`

### reactor.glob.guard
```elixir
guard fun
```


Provides a flexible method for conditionally executing a step, or replacing it's result.

Expects a two arity function which takes the step's arguments and context and returns one of the following:

- `:cont` - the guard has passed.
- `{:halt, result}` - the guard has failed - instead of executing the step use the provided result.




### Examples
```
step :read_file_via_cache do
  argument :path, input(:path)
  run &File.read(&1.path)
  guard fn %{path: path}, %{cache: cache} ->
    case Cache.get(cache, path) do
      {:ok, content} -> {:halt, {:ok, content}}
      _ -> :cont
    end
  end
end

```



### Arguments

| Name | Type | Default | Docs |
|------|------|---------|------|
| [`fun`](#reactor-glob-guard-fun){: #reactor-glob-guard-fun .spark-required} | `(any, any -> any) \| mfa` |  | The guard function. |
### Options

| Name | Type | Default | Docs |
|------|------|---------|------|
| [`description`](#reactor-glob-guard-description){: #reactor-glob-guard-description } | `String.t` |  | An optional description of the guard. |





### Introspection

Target: `Reactor.Dsl.Guard`

### reactor.glob.where
```elixir
where predicate
```


Only execute the surrounding step if the predicate function returns true.

This is a simple version of `guard` which provides more flexibility at the cost of complexity.




### Examples
```
step :read_file do
  argument :path, input(:path)
  run &File.read(&1.path)
  where &File.exists?(&1.path)
end

```



### Arguments

| Name | Type | Default | Docs |
|------|------|---------|------|
| [`predicate`](#reactor-glob-where-predicate){: #reactor-glob-where-predicate .spark-required} | `(any -> any) \| mfa \| (any, any -> any) \| mfa` |  | Provide a function which takes the step arguments and optionally the context and returns a boolean value. |
### Options

| Name | Type | Default | Docs |
|------|------|---------|------|
| [`description`](#reactor-glob-where-description){: #reactor-glob-where-description } | `String.t` |  | An optional description of the guard. |





### Introspection

Target: `Reactor.Dsl.Where`




### Introspection

Target: `Reactor.File.Dsl.Glob`



### reactor.ln
```elixir
ln name
```


Create a hard link from `existing` to `new`.

Uses `File.ln/2`.


### Nested DSLs
 * [wait_for](#reactor-ln-wait_for)
 * [guard](#reactor-ln-guard)
 * [where](#reactor-ln-where)




### Arguments

| Name | Type | Default | Docs |
|------|------|---------|------|
| [`name`](#reactor-ln-name){: #reactor-ln-name .spark-required} | `atom` |  | A unique name for the step. Used when choosing the return value of the Reactor and for arguments into other steps |
### Options

| Name | Type | Default | Docs |
|------|------|---------|------|
| [`existing`](#reactor-ln-existing){: #reactor-ln-existing .spark-required} | `Reactor.Template.Element \| Reactor.Template.Input \| Reactor.Template.Result \| Reactor.Template.Value` |  | The path to the existing file |
| [`new`](#reactor-ln-new){: #reactor-ln-new .spark-required} | `Reactor.Template.Element \| Reactor.Template.Input \| Reactor.Template.Result \| Reactor.Template.Value` |  | The path to the new file |
| [`description`](#reactor-ln-description){: #reactor-ln-description } | `String.t` |  | An optional description for the step |
| [`overwrite?`](#reactor-ln-overwrite?){: #reactor-ln-overwrite? } | `boolean` | `true` | Whether or not to overwrite the new if it already exists |
| [`revert_on_undo?`](#reactor-ln-revert_on_undo?){: #reactor-ln-revert_on_undo? } | `boolean` | `false` | Revert back to the initial state on undo (either by removing the new or by setting it back to it's original content) |


### reactor.ln.wait_for
```elixir
wait_for names
```


Wait for the named step to complete before allowing this one to start.

Desugars to `argument :_, result(step_to_wait_for)`




### Examples
```
wait_for :create_user
```



### Arguments

| Name | Type | Default | Docs |
|------|------|---------|------|
| [`names`](#reactor-ln-wait_for-names){: #reactor-ln-wait_for-names .spark-required} | `atom \| list(atom)` |  | The name of the step to wait for. |
### Options

| Name | Type | Default | Docs |
|------|------|---------|------|
| [`description`](#reactor-ln-wait_for-description){: #reactor-ln-wait_for-description } | `String.t` |  | An optional description. |





### Introspection

Target: `Reactor.Dsl.WaitFor`

### reactor.ln.guard
```elixir
guard fun
```


Provides a flexible method for conditionally executing a step, or replacing it's result.

Expects a two arity function which takes the step's arguments and context and returns one of the following:

- `:cont` - the guard has passed.
- `{:halt, result}` - the guard has failed - instead of executing the step use the provided result.




### Examples
```
step :read_file_via_cache do
  argument :path, input(:path)
  run &File.read(&1.path)
  guard fn %{path: path}, %{cache: cache} ->
    case Cache.get(cache, path) do
      {:ok, content} -> {:halt, {:ok, content}}
      _ -> :cont
    end
  end
end

```



### Arguments

| Name | Type | Default | Docs |
|------|------|---------|------|
| [`fun`](#reactor-ln-guard-fun){: #reactor-ln-guard-fun .spark-required} | `(any, any -> any) \| mfa` |  | The guard function. |
### Options

| Name | Type | Default | Docs |
|------|------|---------|------|
| [`description`](#reactor-ln-guard-description){: #reactor-ln-guard-description } | `String.t` |  | An optional description of the guard. |





### Introspection

Target: `Reactor.Dsl.Guard`

### reactor.ln.where
```elixir
where predicate
```


Only execute the surrounding step if the predicate function returns true.

This is a simple version of `guard` which provides more flexibility at the cost of complexity.




### Examples
```
step :read_file do
  argument :path, input(:path)
  run &File.read(&1.path)
  where &File.exists?(&1.path)
end

```



### Arguments

| Name | Type | Default | Docs |
|------|------|---------|------|
| [`predicate`](#reactor-ln-where-predicate){: #reactor-ln-where-predicate .spark-required} | `(any -> any) \| mfa \| (any, any -> any) \| mfa` |  | Provide a function which takes the step arguments and optionally the context and returns a boolean value. |
### Options

| Name | Type | Default | Docs |
|------|------|---------|------|
| [`description`](#reactor-ln-where-description){: #reactor-ln-where-description } | `String.t` |  | An optional description of the guard. |





### Introspection

Target: `Reactor.Dsl.Where`




### Introspection

Target: `Reactor.File.Dsl.Ln`



### reactor.ln_s
```elixir
ln_s name
```


Create a symbolic link from `existing` to `new`.

Uses `File.ln_s/2`.


### Nested DSLs
 * [wait_for](#reactor-ln_s-wait_for)
 * [guard](#reactor-ln_s-guard)
 * [where](#reactor-ln_s-where)




### Arguments

| Name | Type | Default | Docs |
|------|------|---------|------|
| [`name`](#reactor-ln_s-name){: #reactor-ln_s-name .spark-required} | `atom` |  | A unique name for the step. Used when choosing the return value of the Reactor and for arguments into other steps |
### Options

| Name | Type | Default | Docs |
|------|------|---------|------|
| [`existing`](#reactor-ln_s-existing){: #reactor-ln_s-existing .spark-required} | `Reactor.Template.Element \| Reactor.Template.Input \| Reactor.Template.Result \| Reactor.Template.Value` |  | The path to the existing file |
| [`new`](#reactor-ln_s-new){: #reactor-ln_s-new .spark-required} | `Reactor.Template.Element \| Reactor.Template.Input \| Reactor.Template.Result \| Reactor.Template.Value` |  | The path to the new file |
| [`description`](#reactor-ln_s-description){: #reactor-ln_s-description } | `String.t` |  | An optional description for the step |
| [`overwrite?`](#reactor-ln_s-overwrite?){: #reactor-ln_s-overwrite? } | `boolean` | `true` | Whether or not to overwrite the new if it already exists |
| [`revert_on_undo?`](#reactor-ln_s-revert_on_undo?){: #reactor-ln_s-revert_on_undo? } | `boolean` | `false` | Revert back to the initial state on undo (either by removing the new or by setting it back to it's original content) |


### reactor.ln_s.wait_for
```elixir
wait_for names
```


Wait for the named step to complete before allowing this one to start.

Desugars to `argument :_, result(step_to_wait_for)`




### Examples
```
wait_for :create_user
```



### Arguments

| Name | Type | Default | Docs |
|------|------|---------|------|
| [`names`](#reactor-ln_s-wait_for-names){: #reactor-ln_s-wait_for-names .spark-required} | `atom \| list(atom)` |  | The name of the step to wait for. |
### Options

| Name | Type | Default | Docs |
|------|------|---------|------|
| [`description`](#reactor-ln_s-wait_for-description){: #reactor-ln_s-wait_for-description } | `String.t` |  | An optional description. |





### Introspection

Target: `Reactor.Dsl.WaitFor`

### reactor.ln_s.guard
```elixir
guard fun
```


Provides a flexible method for conditionally executing a step, or replacing it's result.

Expects a two arity function which takes the step's arguments and context and returns one of the following:

- `:cont` - the guard has passed.
- `{:halt, result}` - the guard has failed - instead of executing the step use the provided result.




### Examples
```
step :read_file_via_cache do
  argument :path, input(:path)
  run &File.read(&1.path)
  guard fn %{path: path}, %{cache: cache} ->
    case Cache.get(cache, path) do
      {:ok, content} -> {:halt, {:ok, content}}
      _ -> :cont
    end
  end
end

```



### Arguments

| Name | Type | Default | Docs |
|------|------|---------|------|
| [`fun`](#reactor-ln_s-guard-fun){: #reactor-ln_s-guard-fun .spark-required} | `(any, any -> any) \| mfa` |  | The guard function. |
### Options

| Name | Type | Default | Docs |
|------|------|---------|------|
| [`description`](#reactor-ln_s-guard-description){: #reactor-ln_s-guard-description } | `String.t` |  | An optional description of the guard. |





### Introspection

Target: `Reactor.Dsl.Guard`

### reactor.ln_s.where
```elixir
where predicate
```


Only execute the surrounding step if the predicate function returns true.

This is a simple version of `guard` which provides more flexibility at the cost of complexity.




### Examples
```
step :read_file do
  argument :path, input(:path)
  run &File.read(&1.path)
  where &File.exists?(&1.path)
end

```



### Arguments

| Name | Type | Default | Docs |
|------|------|---------|------|
| [`predicate`](#reactor-ln_s-where-predicate){: #reactor-ln_s-where-predicate .spark-required} | `(any -> any) \| mfa \| (any, any -> any) \| mfa` |  | Provide a function which takes the step arguments and optionally the context and returns a boolean value. |
### Options

| Name | Type | Default | Docs |
|------|------|---------|------|
| [`description`](#reactor-ln_s-where-description){: #reactor-ln_s-where-description } | `String.t` |  | An optional description of the guard. |





### Introspection

Target: `Reactor.Dsl.Where`




### Introspection

Target: `Reactor.File.Dsl.LnS`



### reactor.lstat
```elixir
lstat name
```


Returns information about a path.

If the file is a symlink, sets the type to `:symlink` and returns a
`File.Stat` struct for the link. For any other file, returns exactly the
same values as `stat`.

See `File.lstat/2` for more information.


### Nested DSLs
 * [wait_for](#reactor-lstat-wait_for)
 * [guard](#reactor-lstat-guard)
 * [where](#reactor-lstat-where)




### Arguments

| Name | Type | Default | Docs |
|------|------|---------|------|
| [`name`](#reactor-lstat-name){: #reactor-lstat-name .spark-required} | `atom` |  | A unique name for the step. Used when choosing the return value of the Reactor and for arguments into other steps |
### Options

| Name | Type | Default | Docs |
|------|------|---------|------|
| [`path`](#reactor-lstat-path){: #reactor-lstat-path .spark-required} | `Reactor.Template.Element \| Reactor.Template.Input \| Reactor.Template.Result \| Reactor.Template.Value` |  | The path of the directory to create |
| [`description`](#reactor-lstat-description){: #reactor-lstat-description } | `String.t` |  | An optional description for the step |
| [`time`](#reactor-lstat-time){: #reactor-lstat-time } | `:universal \| :local \| :posix` | `:posix` | What format to return the file times in. See `File.stat/2` for more. |


### reactor.lstat.wait_for
```elixir
wait_for names
```


Wait for the named step to complete before allowing this one to start.

Desugars to `argument :_, result(step_to_wait_for)`




### Examples
```
wait_for :create_user
```



### Arguments

| Name | Type | Default | Docs |
|------|------|---------|------|
| [`names`](#reactor-lstat-wait_for-names){: #reactor-lstat-wait_for-names .spark-required} | `atom \| list(atom)` |  | The name of the step to wait for. |
### Options

| Name | Type | Default | Docs |
|------|------|---------|------|
| [`description`](#reactor-lstat-wait_for-description){: #reactor-lstat-wait_for-description } | `String.t` |  | An optional description. |





### Introspection

Target: `Reactor.Dsl.WaitFor`

### reactor.lstat.guard
```elixir
guard fun
```


Provides a flexible method for conditionally executing a step, or replacing it's result.

Expects a two arity function which takes the step's arguments and context and returns one of the following:

- `:cont` - the guard has passed.
- `{:halt, result}` - the guard has failed - instead of executing the step use the provided result.




### Examples
```
step :read_file_via_cache do
  argument :path, input(:path)
  run &File.read(&1.path)
  guard fn %{path: path}, %{cache: cache} ->
    case Cache.get(cache, path) do
      {:ok, content} -> {:halt, {:ok, content}}
      _ -> :cont
    end
  end
end

```



### Arguments

| Name | Type | Default | Docs |
|------|------|---------|------|
| [`fun`](#reactor-lstat-guard-fun){: #reactor-lstat-guard-fun .spark-required} | `(any, any -> any) \| mfa` |  | The guard function. |
### Options

| Name | Type | Default | Docs |
|------|------|---------|------|
| [`description`](#reactor-lstat-guard-description){: #reactor-lstat-guard-description } | `String.t` |  | An optional description of the guard. |





### Introspection

Target: `Reactor.Dsl.Guard`

### reactor.lstat.where
```elixir
where predicate
```


Only execute the surrounding step if the predicate function returns true.

This is a simple version of `guard` which provides more flexibility at the cost of complexity.




### Examples
```
step :read_file do
  argument :path, input(:path)
  run &File.read(&1.path)
  where &File.exists?(&1.path)
end

```



### Arguments

| Name | Type | Default | Docs |
|------|------|---------|------|
| [`predicate`](#reactor-lstat-where-predicate){: #reactor-lstat-where-predicate .spark-required} | `(any -> any) \| mfa \| (any, any -> any) \| mfa` |  | Provide a function which takes the step arguments and optionally the context and returns a boolean value. |
### Options

| Name | Type | Default | Docs |
|------|------|---------|------|
| [`description`](#reactor-lstat-where-description){: #reactor-lstat-where-description } | `String.t` |  | An optional description of the guard. |





### Introspection

Target: `Reactor.Dsl.Where`




### Introspection

Target: `Reactor.File.Dsl.Lstat`



### reactor.mkdir
```elixir
mkdir name
```


Creates a directory.

Uses `File.mkdir/1`.


### Nested DSLs
 * [wait_for](#reactor-mkdir-wait_for)
 * [guard](#reactor-mkdir-guard)
 * [where](#reactor-mkdir-where)




### Arguments

| Name | Type | Default | Docs |
|------|------|---------|------|
| [`name`](#reactor-mkdir-name){: #reactor-mkdir-name .spark-required} | `atom` |  | A unique name for the step. Used when choosing the return value of the Reactor and for arguments into other steps |
### Options

| Name | Type | Default | Docs |
|------|------|---------|------|
| [`path`](#reactor-mkdir-path){: #reactor-mkdir-path .spark-required} | `Reactor.Template.Element \| Reactor.Template.Input \| Reactor.Template.Result \| Reactor.Template.Value` |  | The path of the directory to create |
| [`description`](#reactor-mkdir-description){: #reactor-mkdir-description } | `String.t` |  | An optional description for the step |
| [`revert_on_undo?`](#reactor-mkdir-revert_on_undo?){: #reactor-mkdir-revert_on_undo? } | `boolean` | `false` | Remove the created directory if the Reactor is undoing changes |


### reactor.mkdir.wait_for
```elixir
wait_for names
```


Wait for the named step to complete before allowing this one to start.

Desugars to `argument :_, result(step_to_wait_for)`




### Examples
```
wait_for :create_user
```



### Arguments

| Name | Type | Default | Docs |
|------|------|---------|------|
| [`names`](#reactor-mkdir-wait_for-names){: #reactor-mkdir-wait_for-names .spark-required} | `atom \| list(atom)` |  | The name of the step to wait for. |
### Options

| Name | Type | Default | Docs |
|------|------|---------|------|
| [`description`](#reactor-mkdir-wait_for-description){: #reactor-mkdir-wait_for-description } | `String.t` |  | An optional description. |





### Introspection

Target: `Reactor.Dsl.WaitFor`

### reactor.mkdir.guard
```elixir
guard fun
```


Provides a flexible method for conditionally executing a step, or replacing it's result.

Expects a two arity function which takes the step's arguments and context and returns one of the following:

- `:cont` - the guard has passed.
- `{:halt, result}` - the guard has failed - instead of executing the step use the provided result.




### Examples
```
step :read_file_via_cache do
  argument :path, input(:path)
  run &File.read(&1.path)
  guard fn %{path: path}, %{cache: cache} ->
    case Cache.get(cache, path) do
      {:ok, content} -> {:halt, {:ok, content}}
      _ -> :cont
    end
  end
end

```



### Arguments

| Name | Type | Default | Docs |
|------|------|---------|------|
| [`fun`](#reactor-mkdir-guard-fun){: #reactor-mkdir-guard-fun .spark-required} | `(any, any -> any) \| mfa` |  | The guard function. |
### Options

| Name | Type | Default | Docs |
|------|------|---------|------|
| [`description`](#reactor-mkdir-guard-description){: #reactor-mkdir-guard-description } | `String.t` |  | An optional description of the guard. |





### Introspection

Target: `Reactor.Dsl.Guard`

### reactor.mkdir.where
```elixir
where predicate
```


Only execute the surrounding step if the predicate function returns true.

This is a simple version of `guard` which provides more flexibility at the cost of complexity.




### Examples
```
step :read_file do
  argument :path, input(:path)
  run &File.read(&1.path)
  where &File.exists?(&1.path)
end

```



### Arguments

| Name | Type | Default | Docs |
|------|------|---------|------|
| [`predicate`](#reactor-mkdir-where-predicate){: #reactor-mkdir-where-predicate .spark-required} | `(any -> any) \| mfa \| (any, any -> any) \| mfa` |  | Provide a function which takes the step arguments and optionally the context and returns a boolean value. |
### Options

| Name | Type | Default | Docs |
|------|------|---------|------|
| [`description`](#reactor-mkdir-where-description){: #reactor-mkdir-where-description } | `String.t` |  | An optional description of the guard. |





### Introspection

Target: `Reactor.Dsl.Where`




### Introspection

Target: `Reactor.File.Dsl.Mkdir`



### reactor.mkdir_p
```elixir
mkdir_p name
```


Creates a directory and any intermediate directories which also must be created.

Uses `File.mkdir_p/1`.


### Nested DSLs
 * [wait_for](#reactor-mkdir_p-wait_for)
 * [guard](#reactor-mkdir_p-guard)
 * [where](#reactor-mkdir_p-where)




### Arguments

| Name | Type | Default | Docs |
|------|------|---------|------|
| [`name`](#reactor-mkdir_p-name){: #reactor-mkdir_p-name .spark-required} | `atom` |  | A unique name for the step. Used when choosing the return value of the Reactor and for arguments into other steps |
### Options

| Name | Type | Default | Docs |
|------|------|---------|------|
| [`path`](#reactor-mkdir_p-path){: #reactor-mkdir_p-path .spark-required} | `Reactor.Template.Element \| Reactor.Template.Input \| Reactor.Template.Result \| Reactor.Template.Value` |  | The path of the directory to create |
| [`description`](#reactor-mkdir_p-description){: #reactor-mkdir_p-description } | `String.t` |  | An optional description for the step |
| [`revert_on_undo?`](#reactor-mkdir_p-revert_on_undo?){: #reactor-mkdir_p-revert_on_undo? } | `boolean` | `false` | Remove the created directory if the Reactor is undoing changes |


### reactor.mkdir_p.wait_for
```elixir
wait_for names
```


Wait for the named step to complete before allowing this one to start.

Desugars to `argument :_, result(step_to_wait_for)`




### Examples
```
wait_for :create_user
```



### Arguments

| Name | Type | Default | Docs |
|------|------|---------|------|
| [`names`](#reactor-mkdir_p-wait_for-names){: #reactor-mkdir_p-wait_for-names .spark-required} | `atom \| list(atom)` |  | The name of the step to wait for. |
### Options

| Name | Type | Default | Docs |
|------|------|---------|------|
| [`description`](#reactor-mkdir_p-wait_for-description){: #reactor-mkdir_p-wait_for-description } | `String.t` |  | An optional description. |





### Introspection

Target: `Reactor.Dsl.WaitFor`

### reactor.mkdir_p.guard
```elixir
guard fun
```


Provides a flexible method for conditionally executing a step, or replacing it's result.

Expects a two arity function which takes the step's arguments and context and returns one of the following:

- `:cont` - the guard has passed.
- `{:halt, result}` - the guard has failed - instead of executing the step use the provided result.




### Examples
```
step :read_file_via_cache do
  argument :path, input(:path)
  run &File.read(&1.path)
  guard fn %{path: path}, %{cache: cache} ->
    case Cache.get(cache, path) do
      {:ok, content} -> {:halt, {:ok, content}}
      _ -> :cont
    end
  end
end

```



### Arguments

| Name | Type | Default | Docs |
|------|------|---------|------|
| [`fun`](#reactor-mkdir_p-guard-fun){: #reactor-mkdir_p-guard-fun .spark-required} | `(any, any -> any) \| mfa` |  | The guard function. |
### Options

| Name | Type | Default | Docs |
|------|------|---------|------|
| [`description`](#reactor-mkdir_p-guard-description){: #reactor-mkdir_p-guard-description } | `String.t` |  | An optional description of the guard. |





### Introspection

Target: `Reactor.Dsl.Guard`

### reactor.mkdir_p.where
```elixir
where predicate
```


Only execute the surrounding step if the predicate function returns true.

This is a simple version of `guard` which provides more flexibility at the cost of complexity.




### Examples
```
step :read_file do
  argument :path, input(:path)
  run &File.read(&1.path)
  where &File.exists?(&1.path)
end

```



### Arguments

| Name | Type | Default | Docs |
|------|------|---------|------|
| [`predicate`](#reactor-mkdir_p-where-predicate){: #reactor-mkdir_p-where-predicate .spark-required} | `(any -> any) \| mfa \| (any, any -> any) \| mfa` |  | Provide a function which takes the step arguments and optionally the context and returns a boolean value. |
### Options

| Name | Type | Default | Docs |
|------|------|---------|------|
| [`description`](#reactor-mkdir_p-where-description){: #reactor-mkdir_p-where-description } | `String.t` |  | An optional description of the guard. |





### Introspection

Target: `Reactor.Dsl.Where`




### Introspection

Target: `Reactor.File.Dsl.MkdirP`



### reactor.read_link
```elixir
read_link name
```


Reads a symbolic link.

Uses `File.read_link/1`.


### Nested DSLs
 * [wait_for](#reactor-read_link-wait_for)
 * [guard](#reactor-read_link-guard)
 * [where](#reactor-read_link-where)




### Arguments

| Name | Type | Default | Docs |
|------|------|---------|------|
| [`name`](#reactor-read_link-name){: #reactor-read_link-name .spark-required} | `atom` |  | A unique name for the step. Used when choosing the return value of the Reactor and for arguments into other steps |
### Options

| Name | Type | Default | Docs |
|------|------|---------|------|
| [`path`](#reactor-read_link-path){: #reactor-read_link-path .spark-required} | `Reactor.Template.Element \| Reactor.Template.Input \| Reactor.Template.Result \| Reactor.Template.Value` |  | The path to the link to read |
| [`description`](#reactor-read_link-description){: #reactor-read_link-description } | `String.t` |  | An optional description for the step |


### reactor.read_link.wait_for
```elixir
wait_for names
```


Wait for the named step to complete before allowing this one to start.

Desugars to `argument :_, result(step_to_wait_for)`




### Examples
```
wait_for :create_user
```



### Arguments

| Name | Type | Default | Docs |
|------|------|---------|------|
| [`names`](#reactor-read_link-wait_for-names){: #reactor-read_link-wait_for-names .spark-required} | `atom \| list(atom)` |  | The name of the step to wait for. |
### Options

| Name | Type | Default | Docs |
|------|------|---------|------|
| [`description`](#reactor-read_link-wait_for-description){: #reactor-read_link-wait_for-description } | `String.t` |  | An optional description. |





### Introspection

Target: `Reactor.Dsl.WaitFor`

### reactor.read_link.guard
```elixir
guard fun
```


Provides a flexible method for conditionally executing a step, or replacing it's result.

Expects a two arity function which takes the step's arguments and context and returns one of the following:

- `:cont` - the guard has passed.
- `{:halt, result}` - the guard has failed - instead of executing the step use the provided result.




### Examples
```
step :read_file_via_cache do
  argument :path, input(:path)
  run &File.read(&1.path)
  guard fn %{path: path}, %{cache: cache} ->
    case Cache.get(cache, path) do
      {:ok, content} -> {:halt, {:ok, content}}
      _ -> :cont
    end
  end
end

```



### Arguments

| Name | Type | Default | Docs |
|------|------|---------|------|
| [`fun`](#reactor-read_link-guard-fun){: #reactor-read_link-guard-fun .spark-required} | `(any, any -> any) \| mfa` |  | The guard function. |
### Options

| Name | Type | Default | Docs |
|------|------|---------|------|
| [`description`](#reactor-read_link-guard-description){: #reactor-read_link-guard-description } | `String.t` |  | An optional description of the guard. |





### Introspection

Target: `Reactor.Dsl.Guard`

### reactor.read_link.where
```elixir
where predicate
```


Only execute the surrounding step if the predicate function returns true.

This is a simple version of `guard` which provides more flexibility at the cost of complexity.




### Examples
```
step :read_file do
  argument :path, input(:path)
  run &File.read(&1.path)
  where &File.exists?(&1.path)
end

```



### Arguments

| Name | Type | Default | Docs |
|------|------|---------|------|
| [`predicate`](#reactor-read_link-where-predicate){: #reactor-read_link-where-predicate .spark-required} | `(any -> any) \| mfa \| (any, any -> any) \| mfa` |  | Provide a function which takes the step arguments and optionally the context and returns a boolean value. |
### Options

| Name | Type | Default | Docs |
|------|------|---------|------|
| [`description`](#reactor-read_link-where-description){: #reactor-read_link-where-description } | `String.t` |  | An optional description of the guard. |





### Introspection

Target: `Reactor.Dsl.Where`




### Introspection

Target: `Reactor.File.Dsl.ReadLink`



### reactor.rm
```elixir
rm name
```


Removes a file.

Uses `File.rm/1`.


### Nested DSLs
 * [wait_for](#reactor-rm-wait_for)
 * [guard](#reactor-rm-guard)
 * [where](#reactor-rm-where)




### Arguments

| Name | Type | Default | Docs |
|------|------|---------|------|
| [`name`](#reactor-rm-name){: #reactor-rm-name .spark-required} | `atom` |  | A unique name for the step. Used when choosing the return value of the Reactor and for arguments into other steps |
### Options

| Name | Type | Default | Docs |
|------|------|---------|------|
| [`path`](#reactor-rm-path){: #reactor-rm-path .spark-required} | `Reactor.Template.Element \| Reactor.Template.Input \| Reactor.Template.Result \| Reactor.Template.Value` |  | The path to the file to remove |
| [`description`](#reactor-rm-description){: #reactor-rm-description } | `String.t` |  | An optional description for the step |
| [`revert_on_undo?`](#reactor-rm-revert_on_undo?){: #reactor-rm-revert_on_undo? } | `boolean` | `false` | Replace the original file if the Reactor is undoing changes |


### reactor.rm.wait_for
```elixir
wait_for names
```


Wait for the named step to complete before allowing this one to start.

Desugars to `argument :_, result(step_to_wait_for)`




### Examples
```
wait_for :create_user
```



### Arguments

| Name | Type | Default | Docs |
|------|------|---------|------|
| [`names`](#reactor-rm-wait_for-names){: #reactor-rm-wait_for-names .spark-required} | `atom \| list(atom)` |  | The name of the step to wait for. |
### Options

| Name | Type | Default | Docs |
|------|------|---------|------|
| [`description`](#reactor-rm-wait_for-description){: #reactor-rm-wait_for-description } | `String.t` |  | An optional description. |





### Introspection

Target: `Reactor.Dsl.WaitFor`

### reactor.rm.guard
```elixir
guard fun
```


Provides a flexible method for conditionally executing a step, or replacing it's result.

Expects a two arity function which takes the step's arguments and context and returns one of the following:

- `:cont` - the guard has passed.
- `{:halt, result}` - the guard has failed - instead of executing the step use the provided result.




### Examples
```
step :read_file_via_cache do
  argument :path, input(:path)
  run &File.read(&1.path)
  guard fn %{path: path}, %{cache: cache} ->
    case Cache.get(cache, path) do
      {:ok, content} -> {:halt, {:ok, content}}
      _ -> :cont
    end
  end
end

```



### Arguments

| Name | Type | Default | Docs |
|------|------|---------|------|
| [`fun`](#reactor-rm-guard-fun){: #reactor-rm-guard-fun .spark-required} | `(any, any -> any) \| mfa` |  | The guard function. |
### Options

| Name | Type | Default | Docs |
|------|------|---------|------|
| [`description`](#reactor-rm-guard-description){: #reactor-rm-guard-description } | `String.t` |  | An optional description of the guard. |





### Introspection

Target: `Reactor.Dsl.Guard`

### reactor.rm.where
```elixir
where predicate
```


Only execute the surrounding step if the predicate function returns true.

This is a simple version of `guard` which provides more flexibility at the cost of complexity.




### Examples
```
step :read_file do
  argument :path, input(:path)
  run &File.read(&1.path)
  where &File.exists?(&1.path)
end

```



### Arguments

| Name | Type | Default | Docs |
|------|------|---------|------|
| [`predicate`](#reactor-rm-where-predicate){: #reactor-rm-where-predicate .spark-required} | `(any -> any) \| mfa \| (any, any -> any) \| mfa` |  | Provide a function which takes the step arguments and optionally the context and returns a boolean value. |
### Options

| Name | Type | Default | Docs |
|------|------|---------|------|
| [`description`](#reactor-rm-where-description){: #reactor-rm-where-description } | `String.t` |  | An optional description of the guard. |





### Introspection

Target: `Reactor.Dsl.Where`




### Introspection

Target: `Reactor.File.Dsl.Rm`



### reactor.rmdir
```elixir
rmdir name
```


Removes a directory.

Uses `File.rmdir/1`.


### Nested DSLs
 * [wait_for](#reactor-rmdir-wait_for)
 * [guard](#reactor-rmdir-guard)
 * [where](#reactor-rmdir-where)




### Arguments

| Name | Type | Default | Docs |
|------|------|---------|------|
| [`name`](#reactor-rmdir-name){: #reactor-rmdir-name .spark-required} | `atom` |  | A unique name for the step. Used when choosing the return value of the Reactor and for arguments into other steps |
### Options

| Name | Type | Default | Docs |
|------|------|---------|------|
| [`path`](#reactor-rmdir-path){: #reactor-rmdir-path .spark-required} | `Reactor.Template.Element \| Reactor.Template.Input \| Reactor.Template.Result \| Reactor.Template.Value` |  | The path of the directory to remove |
| [`description`](#reactor-rmdir-description){: #reactor-rmdir-description } | `String.t` |  | An optional description for the step |
| [`revert_on_undo?`](#reactor-rmdir-revert_on_undo?){: #reactor-rmdir-revert_on_undo? } | `boolean` | `false` | Recreate the directory if the Reactor is undoing changes |


### reactor.rmdir.wait_for
```elixir
wait_for names
```


Wait for the named step to complete before allowing this one to start.

Desugars to `argument :_, result(step_to_wait_for)`




### Examples
```
wait_for :create_user
```



### Arguments

| Name | Type | Default | Docs |
|------|------|---------|------|
| [`names`](#reactor-rmdir-wait_for-names){: #reactor-rmdir-wait_for-names .spark-required} | `atom \| list(atom)` |  | The name of the step to wait for. |
### Options

| Name | Type | Default | Docs |
|------|------|---------|------|
| [`description`](#reactor-rmdir-wait_for-description){: #reactor-rmdir-wait_for-description } | `String.t` |  | An optional description. |





### Introspection

Target: `Reactor.Dsl.WaitFor`

### reactor.rmdir.guard
```elixir
guard fun
```


Provides a flexible method for conditionally executing a step, or replacing it's result.

Expects a two arity function which takes the step's arguments and context and returns one of the following:

- `:cont` - the guard has passed.
- `{:halt, result}` - the guard has failed - instead of executing the step use the provided result.




### Examples
```
step :read_file_via_cache do
  argument :path, input(:path)
  run &File.read(&1.path)
  guard fn %{path: path}, %{cache: cache} ->
    case Cache.get(cache, path) do
      {:ok, content} -> {:halt, {:ok, content}}
      _ -> :cont
    end
  end
end

```



### Arguments

| Name | Type | Default | Docs |
|------|------|---------|------|
| [`fun`](#reactor-rmdir-guard-fun){: #reactor-rmdir-guard-fun .spark-required} | `(any, any -> any) \| mfa` |  | The guard function. |
### Options

| Name | Type | Default | Docs |
|------|------|---------|------|
| [`description`](#reactor-rmdir-guard-description){: #reactor-rmdir-guard-description } | `String.t` |  | An optional description of the guard. |





### Introspection

Target: `Reactor.Dsl.Guard`

### reactor.rmdir.where
```elixir
where predicate
```


Only execute the surrounding step if the predicate function returns true.

This is a simple version of `guard` which provides more flexibility at the cost of complexity.




### Examples
```
step :read_file do
  argument :path, input(:path)
  run &File.read(&1.path)
  where &File.exists?(&1.path)
end

```



### Arguments

| Name | Type | Default | Docs |
|------|------|---------|------|
| [`predicate`](#reactor-rmdir-where-predicate){: #reactor-rmdir-where-predicate .spark-required} | `(any -> any) \| mfa \| (any, any -> any) \| mfa` |  | Provide a function which takes the step arguments and optionally the context and returns a boolean value. |
### Options

| Name | Type | Default | Docs |
|------|------|---------|------|
| [`description`](#reactor-rmdir-where-description){: #reactor-rmdir-where-description } | `String.t` |  | An optional description of the guard. |





### Introspection

Target: `Reactor.Dsl.Where`




### Introspection

Target: `Reactor.File.Dsl.Rmdir`



### reactor.stat
```elixir
stat name
```


Returns information about a path.

See `File.stat/2` for more information.


### Nested DSLs
 * [wait_for](#reactor-stat-wait_for)
 * [guard](#reactor-stat-guard)
 * [where](#reactor-stat-where)




### Arguments

| Name | Type | Default | Docs |
|------|------|---------|------|
| [`name`](#reactor-stat-name){: #reactor-stat-name .spark-required} | `atom` |  | A unique name for the step. Used when choosing the return value of the Reactor and for arguments into other steps |
### Options

| Name | Type | Default | Docs |
|------|------|---------|------|
| [`path`](#reactor-stat-path){: #reactor-stat-path .spark-required} | `Reactor.Template.Element \| Reactor.Template.Input \| Reactor.Template.Result \| Reactor.Template.Value` |  | The path of the directory to create |
| [`description`](#reactor-stat-description){: #reactor-stat-description } | `String.t` |  | An optional description for the step |
| [`time`](#reactor-stat-time){: #reactor-stat-time } | `:universal \| :local \| :posix` | `:posix` | What format to return the file times in. See `File.stat/2` for more. |


### reactor.stat.wait_for
```elixir
wait_for names
```


Wait for the named step to complete before allowing this one to start.

Desugars to `argument :_, result(step_to_wait_for)`




### Examples
```
wait_for :create_user
```



### Arguments

| Name | Type | Default | Docs |
|------|------|---------|------|
| [`names`](#reactor-stat-wait_for-names){: #reactor-stat-wait_for-names .spark-required} | `atom \| list(atom)` |  | The name of the step to wait for. |
### Options

| Name | Type | Default | Docs |
|------|------|---------|------|
| [`description`](#reactor-stat-wait_for-description){: #reactor-stat-wait_for-description } | `String.t` |  | An optional description. |





### Introspection

Target: `Reactor.Dsl.WaitFor`

### reactor.stat.guard
```elixir
guard fun
```


Provides a flexible method for conditionally executing a step, or replacing it's result.

Expects a two arity function which takes the step's arguments and context and returns one of the following:

- `:cont` - the guard has passed.
- `{:halt, result}` - the guard has failed - instead of executing the step use the provided result.




### Examples
```
step :read_file_via_cache do
  argument :path, input(:path)
  run &File.read(&1.path)
  guard fn %{path: path}, %{cache: cache} ->
    case Cache.get(cache, path) do
      {:ok, content} -> {:halt, {:ok, content}}
      _ -> :cont
    end
  end
end

```



### Arguments

| Name | Type | Default | Docs |
|------|------|---------|------|
| [`fun`](#reactor-stat-guard-fun){: #reactor-stat-guard-fun .spark-required} | `(any, any -> any) \| mfa` |  | The guard function. |
### Options

| Name | Type | Default | Docs |
|------|------|---------|------|
| [`description`](#reactor-stat-guard-description){: #reactor-stat-guard-description } | `String.t` |  | An optional description of the guard. |





### Introspection

Target: `Reactor.Dsl.Guard`

### reactor.stat.where
```elixir
where predicate
```


Only execute the surrounding step if the predicate function returns true.

This is a simple version of `guard` which provides more flexibility at the cost of complexity.




### Examples
```
step :read_file do
  argument :path, input(:path)
  run &File.read(&1.path)
  where &File.exists?(&1.path)
end

```



### Arguments

| Name | Type | Default | Docs |
|------|------|---------|------|
| [`predicate`](#reactor-stat-where-predicate){: #reactor-stat-where-predicate .spark-required} | `(any -> any) \| mfa \| (any, any -> any) \| mfa` |  | Provide a function which takes the step arguments and optionally the context and returns a boolean value. |
### Options

| Name | Type | Default | Docs |
|------|------|---------|------|
| [`description`](#reactor-stat-where-description){: #reactor-stat-where-description } | `String.t` |  | An optional description of the guard. |





### Introspection

Target: `Reactor.Dsl.Where`




### Introspection

Target: `Reactor.File.Dsl.Stat`



### reactor.touch
```elixir
touch name
```


Update the mtime and atime of a file.

Uses `File.touch/2`.


### Nested DSLs
 * [wait_for](#reactor-touch-wait_for)
 * [guard](#reactor-touch-guard)
 * [where](#reactor-touch-where)




### Arguments

| Name | Type | Default | Docs |
|------|------|---------|------|
| [`name`](#reactor-touch-name){: #reactor-touch-name .spark-required} | `atom` |  | A unique name for the step. Used when choosing the return value of the Reactor and for arguments into other steps |
### Options

| Name | Type | Default | Docs |
|------|------|---------|------|
| [`path`](#reactor-touch-path){: #reactor-touch-path .spark-required} | `Reactor.Template.Element \| Reactor.Template.Input \| Reactor.Template.Result \| Reactor.Template.Value` |  | The path of the directory to remove |
| [`description`](#reactor-touch-description){: #reactor-touch-description } | `String.t` |  | An optional description for the step |
| [`time`](#reactor-touch-time){: #reactor-touch-time } | `Reactor.Template.Element \| Reactor.Template.Input \| Reactor.Template.Result \| Reactor.Template.Value` |  | The time to change the file to. |
| [`revert_on_undo?`](#reactor-touch-revert_on_undo?){: #reactor-touch-revert_on_undo? } | `boolean` | `false` | Recreate the directory if the Reactor is undoing changes |


### reactor.touch.wait_for
```elixir
wait_for names
```


Wait for the named step to complete before allowing this one to start.

Desugars to `argument :_, result(step_to_wait_for)`




### Examples
```
wait_for :create_user
```



### Arguments

| Name | Type | Default | Docs |
|------|------|---------|------|
| [`names`](#reactor-touch-wait_for-names){: #reactor-touch-wait_for-names .spark-required} | `atom \| list(atom)` |  | The name of the step to wait for. |
### Options

| Name | Type | Default | Docs |
|------|------|---------|------|
| [`description`](#reactor-touch-wait_for-description){: #reactor-touch-wait_for-description } | `String.t` |  | An optional description. |





### Introspection

Target: `Reactor.Dsl.WaitFor`

### reactor.touch.guard
```elixir
guard fun
```


Provides a flexible method for conditionally executing a step, or replacing it's result.

Expects a two arity function which takes the step's arguments and context and returns one of the following:

- `:cont` - the guard has passed.
- `{:halt, result}` - the guard has failed - instead of executing the step use the provided result.




### Examples
```
step :read_file_via_cache do
  argument :path, input(:path)
  run &File.read(&1.path)
  guard fn %{path: path}, %{cache: cache} ->
    case Cache.get(cache, path) do
      {:ok, content} -> {:halt, {:ok, content}}
      _ -> :cont
    end
  end
end

```



### Arguments

| Name | Type | Default | Docs |
|------|------|---------|------|
| [`fun`](#reactor-touch-guard-fun){: #reactor-touch-guard-fun .spark-required} | `(any, any -> any) \| mfa` |  | The guard function. |
### Options

| Name | Type | Default | Docs |
|------|------|---------|------|
| [`description`](#reactor-touch-guard-description){: #reactor-touch-guard-description } | `String.t` |  | An optional description of the guard. |





### Introspection

Target: `Reactor.Dsl.Guard`

### reactor.touch.where
```elixir
where predicate
```


Only execute the surrounding step if the predicate function returns true.

This is a simple version of `guard` which provides more flexibility at the cost of complexity.




### Examples
```
step :read_file do
  argument :path, input(:path)
  run &File.read(&1.path)
  where &File.exists?(&1.path)
end

```



### Arguments

| Name | Type | Default | Docs |
|------|------|---------|------|
| [`predicate`](#reactor-touch-where-predicate){: #reactor-touch-where-predicate .spark-required} | `(any -> any) \| mfa \| (any, any -> any) \| mfa` |  | Provide a function which takes the step arguments and optionally the context and returns a boolean value. |
### Options

| Name | Type | Default | Docs |
|------|------|---------|------|
| [`description`](#reactor-touch-where-description){: #reactor-touch-where-description } | `String.t` |  | An optional description of the guard. |





### Introspection

Target: `Reactor.Dsl.Where`




### Introspection

Target: `Reactor.File.Dsl.Touch`



### reactor.write_stat
```elixir
write_stat name
```


Writes the given `File.Stat` back to the filesystem at the given path.


### Nested DSLs
 * [wait_for](#reactor-write_stat-wait_for)
 * [guard](#reactor-write_stat-guard)
 * [where](#reactor-write_stat-where)




### Arguments

| Name | Type | Default | Docs |
|------|------|---------|------|
| [`name`](#reactor-write_stat-name){: #reactor-write_stat-name .spark-required} | `atom` |  | A unique name for the step. Used when choosing the return value of the Reactor and for arguments into other steps |
### Options

| Name | Type | Default | Docs |
|------|------|---------|------|
| [`path`](#reactor-write_stat-path){: #reactor-write_stat-path .spark-required} | `Reactor.Template.Element \| Reactor.Template.Input \| Reactor.Template.Result \| Reactor.Template.Value` |  | The path to the file to modify |
| [`stat`](#reactor-write_stat-stat){: #reactor-write_stat-stat .spark-required} | `Reactor.Template.Element \| Reactor.Template.Input \| Reactor.Template.Result \| Reactor.Template.Value` |  | The stat to write |
| [`description`](#reactor-write_stat-description){: #reactor-write_stat-description } | `String.t` |  | An optional description for the step |
| [`revert_on_undo?`](#reactor-write_stat-revert_on_undo?){: #reactor-write_stat-revert_on_undo? } | `boolean` | `false` | Revert to the original state when undoing changes |
| [`time`](#reactor-write_stat-time){: #reactor-write_stat-time } | `:universal \| :local \| :posix` | `:posix` | What format to return the file times in. See `File.stat/2` for more. |


### reactor.write_stat.wait_for
```elixir
wait_for names
```


Wait for the named step to complete before allowing this one to start.

Desugars to `argument :_, result(step_to_wait_for)`




### Examples
```
wait_for :create_user
```



### Arguments

| Name | Type | Default | Docs |
|------|------|---------|------|
| [`names`](#reactor-write_stat-wait_for-names){: #reactor-write_stat-wait_for-names .spark-required} | `atom \| list(atom)` |  | The name of the step to wait for. |
### Options

| Name | Type | Default | Docs |
|------|------|---------|------|
| [`description`](#reactor-write_stat-wait_for-description){: #reactor-write_stat-wait_for-description } | `String.t` |  | An optional description. |





### Introspection

Target: `Reactor.Dsl.WaitFor`

### reactor.write_stat.guard
```elixir
guard fun
```


Provides a flexible method for conditionally executing a step, or replacing it's result.

Expects a two arity function which takes the step's arguments and context and returns one of the following:

- `:cont` - the guard has passed.
- `{:halt, result}` - the guard has failed - instead of executing the step use the provided result.




### Examples
```
step :read_file_via_cache do
  argument :path, input(:path)
  run &File.read(&1.path)
  guard fn %{path: path}, %{cache: cache} ->
    case Cache.get(cache, path) do
      {:ok, content} -> {:halt, {:ok, content}}
      _ -> :cont
    end
  end
end

```



### Arguments

| Name | Type | Default | Docs |
|------|------|---------|------|
| [`fun`](#reactor-write_stat-guard-fun){: #reactor-write_stat-guard-fun .spark-required} | `(any, any -> any) \| mfa` |  | The guard function. |
### Options

| Name | Type | Default | Docs |
|------|------|---------|------|
| [`description`](#reactor-write_stat-guard-description){: #reactor-write_stat-guard-description } | `String.t` |  | An optional description of the guard. |





### Introspection

Target: `Reactor.Dsl.Guard`

### reactor.write_stat.where
```elixir
where predicate
```


Only execute the surrounding step if the predicate function returns true.

This is a simple version of `guard` which provides more flexibility at the cost of complexity.




### Examples
```
step :read_file do
  argument :path, input(:path)
  run &File.read(&1.path)
  where &File.exists?(&1.path)
end

```



### Arguments

| Name | Type | Default | Docs |
|------|------|---------|------|
| [`predicate`](#reactor-write_stat-where-predicate){: #reactor-write_stat-where-predicate .spark-required} | `(any -> any) \| mfa \| (any, any -> any) \| mfa` |  | Provide a function which takes the step arguments and optionally the context and returns a boolean value. |
### Options

| Name | Type | Default | Docs |
|------|------|---------|------|
| [`description`](#reactor-write_stat-where-description){: #reactor-write_stat-where-description } | `String.t` |  | An optional description of the guard. |





### Introspection

Target: `Reactor.Dsl.Where`




### Introspection

Target: `Reactor.File.Dsl.WriteStat`



<style type="text/css">.spark-required::after { content: "*"; color: red !important; }</style>
